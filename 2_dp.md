## 动态规划

动态规划思考方向：

![「动态规划」问题思考方向.png](\pics\1f95da43d1bdeebdd1213bb804034ddc5f906dc61451cd63f2b5ab5d0eb33b33-「动态规划」问题思考方向.png)动态规划常常适用于**有重叠子问题**和**最优子结构**性质的问题，动态规划方法**所耗时间往往远少于朴素解法**。

### 主要思想

动态规划用于优化递归问题，例如斐波那契数列。动态规划法仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量。

一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。

### 动态规划模板步骤：

- 确定动态规划状态
- 写出状态转移方程（画出状态转移表）
- 考虑初始化条件
- 考虑输出状态
- 考虑对时间，空间复杂度的优化（Bonus）

1、思考状态（重点）

    状态的定义，先尝试「题目问什么，就把什么设置为状态」；
    然后思考「状态如何转移」，如果「状态转移方程」不容易得到，尝试修改定义，目的依然是为了方便得到「状态转移方程」。
    「状态转移方程」是原始问题的不同规模的子问题的联系。即大问题的最优解如何由小问题的最优解得到。

2、思考状态转移方程（核心、难点）

    状态转移方程是非常重要的，是动态规划的核心，也是难点；
    常见的推导技巧是：分类讨论。即：对状态空间进行分类；
    归纳「状态转移方程」是一个很灵活的事情，通常是具体问题具体分析；
    除了掌握经典的动态规划问题以外，还需要多做题；
    如果是针对面试，请自行把握难度。掌握常见问题的动态规划解法，理解动态规划解决问题，是从一个小规模问题出发，逐步得到大问题的解，并记录中间过程；
    「动态规划」方法依然是「空间换时间」思想的体现，常见的解决问题的过程很像在「填表」。

3、思考初始化

初始化是非常重要的，一步错，步步错。初始化状态一定要设置对，才可能得到正确的结果。

    角度 1：直接从状态的语义出发；
    角度 2：如果状态的语义不好思考，就考虑「状态转移方程」的边界需要什么样初始化的条件；
    角度 3：从「状态转移方程」方程的下标看是否需要多设置一行、一列表示「哨兵」（sentinel），这样可以避免一些特殊情况的讨论。

4、思考输出

有些时候是最后一个状态，有些时候可能会综合之前所有计算过的状态。

5、思考优化空间（也可以叫做表格复用）

    「优化空间」会使得代码难于理解，且是的「状态」丢失原来的语义，初学的时候可以不一步到位。先把代码写正确是更重要；
    「优化空间」在有一种情况下是很有必要的，那就是状态空间非常庞大的时候（处理海量数据），此时空间不够用，就必须「优化空间」；
    非常经典的「优化空间」的典型问题是「0-1 背包」问题和「完全背包」问题。

## Leetcode 例题

_________

### [300.最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/) 

### 题目描述

给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例:

```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```

说明:

```
可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
你算法的时间复杂度应该为 O(n2) 。
```

**注**：最长上升子序列不是最大上升子序列，思想一样但结果可能不一样

**子序列：不要求连续**

**子串：要求是连续子序列**

E.g.  

序列(100, 1, 2, 3)的**最大上升子序列和**为100，而**最长上升子序列**为(1, 2, 3)。

现在我们要解决的问题就是在给定的数组中找出最长上升子序列：先给栗子

给定的数组 a[7] = {1,6,4,2,3,9,8}

思想：这里用到的是一个**自底向上**的寻找最优子结构的的思想。粗俗来说：如果你想要得到七个数里面的最长子序列，你可以先找前6个数里面的最长子序列，同理，你又必须得找前5个数里面的最长子序列，直到子序列为1

大体的步骤是这样的

dp[i]: 用数组dp 来存储前第 i 个数的最长子序列的长度, i 表p示的原数组的长度。

​            {1} --------------------------------- dp[1]=1 : 表示第一个数的最长子序列长度是1，最长子序列: {1}

​          {1,6} -------------------------------- dp[2]=dp[1]+1=2 : 表示前两个数中，最长上升子序列长度为2  最长子序列: {1,6}

​        {1,6,4} ------------------------------- dp[3]=dp[1]+1=2 : 因为4 < 6 所以不能用 d[2]+1, 但 1<4 所以 d[3]=d[1]+1。 最长子序列: {1,6},{1,4} 

​       {1,6,4,2} ----------------------------- dp[4]=dp[1]+1=2 : 4和6 都大于2 所以不能用d[2],d[3]+1。 最长子序列: {1,6},{1,4} 

​     {1,6,4,2,3} ---------------------------- dp[5]=dp[4]+1=3 : 3 >2 所以 可以d[4]+1=2+1=3 。 最长子序列: {1,2,3}

   {1,6,4,2,3,9} --------------------------- dp[6]=dp[5]+1= 4 : d[5]+1=3+1=4 。 最长子序列: {1,2,3,9}

  {1,6,4,2,3,9,8} ------------------------- dp[7]=4   最长子序列:  {1,2,3,9} 或者{1,2,3,8}

**注**：动态规划的思想是每一次都从上一个子问题的最优解出发寻找本次问题的最优解。下面的代码dp是代表的nums[i]为结尾的序列的最长上升子序列长度，下标对应上述例子下标-1。

### 解题思路

#### 方法1：常规动态规划

**第一步：确定动态规划状态**

- 是否存在状态转移?

- 什么样的状态比较好转移，找到对求解问题最方便的状态转移?

  该题目可以直接用一个一维数组`dp`来存储转移状态，`dp[i]`可以定义为以`nums[i]`这个数结尾的最长递增子序列的长度。具体操作见上例，注意上例中index不同。

**第二步：写出一个好的状态转移方程**

- 使用**数学归纳法**思维，写出准确的状态方程

  比如还是用刚刚那个`nums`数组，我们**思考一下是如何得到`dp[5]=3`的**：既然是递增的子序列，我们只要找到`nums[5]` (也就是7)前面那些结尾比7小的子序列，然后把7接到最后，就可以形成一个新的递增的子序列，也就是这个新的子序列也就是在找到的前面那些数后面加上7，相当长度加1。即比较当前`dp[i]`的长度和`dp[i]`对应产生新的子序列长度，用`j`来表示所有比`i`小的组数中的索引，可以用如下代码公式表示

  ```python
  for i in range(len(nums)):
      for j in range(i):
      	if nums[i]>nums[j]:
      		dp[i]=max(dp[i],dp[j]+1)
              // 如果结尾新加的数比前面的数都小，dp[i]不更新
              // 否则比较当前最长子序列长度dp[i]和dp[j]+1最大值为新的dp[i]
  ```

  **Tips:** 在实际问题中，如果不能很快得出这个递推公式，可以先尝试一步一步把前面几步写出来，如果还是不行很可能就是 **dp 数组的定义不够恰当**，需要回到第一步重新定义 dp 数组的含义；或者**可能是 dp 数组存储的信息还不够**，不足以推出下一步的答案，需要把 dp 数组扩大成二维数组甚至三维数组。

**第三步：考虑初始条件**

 这是决定整个程序能否跑通的重要步骤，当我们确定好状态转移方程，我们就需要考虑一下边界值，边界值考虑主要又分为三个地方：

- dp数组整体的初始值

- dp数组(二维)i=0和j=0的地方

- dp存放状态的长度，是整个数组的长度还是数组长度加一，这点需要特别注意。

  对于本问题，子序列最少也是自己，所以长度为1，这样我们就可以方便的把所有的`dp`初始化为1，再考虑长度问题，由于`dp[i]`代表的是`nums[i]`为结尾的最长子序列长度，所以并不需要加一。 所以用代码表示就是`dp=[1]*len(nums)`

  **Tips：**还有一点需要注意，找到一个方便的状态转移（**自顶向下还是自下向上**）会使问题变得非常简单。举个例子，对于[Leetcode120.三角形最小路径和](https://leetcode-cn.com/problems/triangle/)问题，大多数人刚开始想到的应该是自顶向下的定义状态转移的思路，也就是从最上面的数开始定义状态转移，但是这题优化的解法则是通过定义由下到上的状态转移方程会大大简化问题，同样的对于[Leetcode53.最大子序和](https://leetcode-cn.com/problems/maximum-subarray/solution/)也是采用从下往上遍历，保证每个子问题都是已经算好的。这个具体我们在题目中会讲到。

  这里额外总结几种Python常用的初始化方法：

  ```
  // 产生一个全为1，长度为n的数组：
  dp=[1 for _ in range(n)]
  dp=[1]*n
  ```

  ```
  // 对于产生一个全为0，m*n 的二维矩阵：
  dp=[[0 for _ in range(n)] for _ in range(m)]
  dp=[[0]*n for _ in range(m)]
  ```

** 第四步：考虑输出状态**

主要有以下三种形式，对于具体问题，我们一定要想清楚到底dp数组里存储的是哪些值，最后我们需要的是数组中的哪些值：

- 返回dp数组中最后一个值作为输出，一般对应二维dp问题。

- 返回dp数组中最大的那个数字，一般对应记录最大值问题。

- 返回保存的最大值，一般是`Maxval=max(Maxval,dp[i])`这样的形式。

  **Tips：**这个公式必须是在满足递增的条件下，也就是`nums[i]>nums[j]`的时候才能成立，并不是`nums[i]`前面所有数字都满足这个条件的，理解好这个条件就很容易懂接下来在输出时候应该是`max(dp)`而不是`dp[-1]`，原因就是dp数组由于计算递增的子序列长度，所以dp数组里中间可能有值会是比最后遍历的数值大的情况，每次遍历`nums[j]`所对应的位置都是比`nums[i]`小的那个数。举个例子，比如`nums=[1,3,6,7,9,4,10,5,6]`,而最后`dp=[1,2,3,4,5,3,6,4,5]`。 总结一下，最后的结果应该返回dp数组中值最大的数。因为找的是最长的上升子序列长度。

  完整代码 ：

  ```python
  def lengthOfLIS(self, nums):
          if not nums:return 0  #判断边界条件（非空）
          dp=[1]*len(nums)      #初始化dp数组状态
          for i in range(len(nums)):
              for j in range(i):
                  if nums[i]>nums[j]:   #根据题目所求得到状态转移方程
                      dp[i]=max(dp[i],dp[j]+1)
          return max(dp)  #确定输出状态
  ```

**第五步：考虑对时间，空间复杂度的优化（Bonus）**

**切入点：** 我们看到，之前方法遍历dp列表需要$O(N)$，计算每个`dp[i]`需要$O(N)$的时间，所以总复杂度是$O(N^2)$

前面遍历dp列表的时间复杂度肯定无法降低了，但是后面计算每个dp[i], 每轮遍历`[0,i]`的`dp[i]`元素的时间复杂度可以考虑设计状态定义，使得整个dp为一个排序列表，这样我们自然想到了可以利用二分法来把时间复杂度降到了$O(NlogN)$。这里由于篇幅原因，如果大家感兴趣的话详细的解题步骤可以看好心人写的[二分方法+动态规划详解](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/):

![image.png](\pics\ee740d492676a26ff7017dd1635ff3af0361ee412f0e1c7bf2ffee032e3dfb4e-image.png)

#### 方法二：修改状态定义（同时用到了**贪心算法、二分查找**）

    依然是着眼于一个上升子序列的结尾的元素；
    如果已经得到的上升子序列的结尾的数越小，遍历的时候后面接上一个数，就会有更大的可能性构成一个更长的上升子序列；
    既然结尾越小越好，我们可以记录在长度固定的情况下，结尾最小的那个元素的数值，这样定义也是为了方便得到「状态转移方程」。

为了与之前的状态区分，这里将状态数组命名为 tail。
第 1 步：定义新状态（特别重要）

**tail[i] 表示长度为 i + 1 的所有上升子序列的结尾的最小值**。

说明：

    tail[0] 表示长度为 1 的所有上升子序列中，结尾最小的那个元素的数值，以题目中的示例为例 [10, 9, 2, 5, 3, 7, 101, 18] 中，容易发现长度为 2 的所有上升子序列中，结尾最小的是子序列 [2, 3] ，因此 tail[1] = 3
    下标和长度有一个 1 的偏差；

状态定义其实也描述了状态转移方程。
第 2 步：思考状态转移方程

从直觉上看，数组 tail 也是一个严格上升数组。我们需要证明一下（略）。只需要维护状态数组 tail 的定义，**最后tail的长度就是最长上升子序列的长度**。

下面说明如何在遍历中，如何维护状态数组 tail 的定义：
算法的执行流程：

1、设置一个数组 tail，初始时为空；

注意：数组 tail 虽然是有序数组，但它不是问题中的「最长上升子序列」（下文还会强调），不能命名为 LIS。有序数组 tail 只是用于求解 LIS 问题的辅助数组。

2、在遍历数组 nums 的过程中，每来一个新数 num，如果这个数**严格大于**有序数组 tail 的最后一个元素，就把 num 放在有序数组 tail 的后面，否则进入第 3 点；

注意：这里的大于是「严格大于」，不包括等于的情况。

3、如果新数num比tail最后一个元素小：在有序数组 tail 中查找第 1 个等于大于 num 的那个数，用num替换这个元素；

    如果有序数组 tail 中存在等于 num 的元素，什么都不做，因为以 num 结尾的最短的「上升子序列」已经存在；
    如果有序数组 tail 中存在大于 num 的元素，找到第 1 个大于等于tail的元素替换成num，这样我们就找到了一个结尾更小的相同长度的上升子序列。

这一步可以认为是「贪心算法」，由于是在有序数组中的操作，因此可以使用「**二分查找算法**」。

4、遍历新的数 num ，先尝试上述第 2 点，第 2 点行不通则执行第 3 点，直到遍历完整个数组 nums，最终有序数组 tail 的长度，就是所求的“最长上升子序列”的长度。

第 3 步：思考初始化

dp[0] = nums[0]，在只有 1 个元素的情况下，它当然是长度为 1 并且结尾最小的元素。

第 4 步：思考输出

数组 tail 的长度，上文其实也已经说了，还是依据定义，tail[i] 表示长度固定为 i + 1 的所有「上升子序列」的结尾元素中最小的那个，**tail的长度恰好就是最长上升子序列的长度**。

第 5 步：思考状态压缩

无法压缩。

```python
# 优化（贪心+二分）
class Solution:
    def lengthOfLIS(self, nums):
        size = len(nums)
        # 特判
        if size < 2:
            return size

        # 为了防止后序逻辑发生数组索引越界，先把第 1 个数放进去
        tail = [nums[0]]
        for i in range(1, size):
            # 【逻辑 1】比 tail 数组实际有效的末尾的那个元素还大
            # 先尝试是否可以接在末尾
            if nums[i] > tail[-1]:
                tail.append(nums[i])
                continue

            # 使用二分查找法，在有序数组 tail 中
            # 找到第 1 个大于等于 nums[i] 的元素，尝试让那个元素更小
            left = 0
            right = len(tail) - 1
            while left < right:
                # 选左中位数不是偶然，而是有原因的，原因请见 LeetCode 第 35 题题解
                # mid = left + (right - left) // 2
                mid = (left + right) >> 1
                if tail[mid] < nums[i]:
                    # 中位数肯定不是要找的数，把它写在分支的前面
                    left = mid + 1
                else:
                    right = mid
            # 走到这里是因为【逻辑 1】的反面，因此一定能找到第 1 个大于等于 nums[i] 的元素，因此无需再单独判断
            tail[left] = nums[i]
        return len(tail)  
```

复杂度分析：

    时间复杂度：O(Nlog⁡N)，遍历数组使用了 O(N)，二分查找法使用了 O(log⁡N)。
    空间复杂度：O(N)，开辟有序数组 tail 的空间至多和原始数组一样。

**模板总结：**

```
        for i in range(len(nums)):
            for j in range(i):
                    dp[i]=最值(dp[i],dp[j]+...)
```

对于子序列问题，很多也都是用这个模板来进行解题，比如[Leetcode53.最大子序和](https://leetcode-cn.com/problems/maximum-subarray/solution/)。此外，其他情况的子序列问题可能需要二维的dp数组来记录状态，比如：[Leetcode5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)（下面会讲到） 、 [Leetcode1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/) (当涉及到两个字符串/数组时) 如果你觉得刚刚那题有点难的话，不如我们从简单一点的题目开始理解一下这类子序列问题。接下来所有题目我们都按照那五个步骤考虑

_____

### [Leetcode 674.最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)

#### 题目描述

给定一个未经排序的整数数组，找到最长且连续的的递增序列。

```
示例 1:
输入: [1,3,5,4,7]
输出: 3
解释: 最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 
```

#### 解题思路

这道题是不是一眼看过去和上题非常的像，这个题目最大的不同就是**连续**两个字，这样就让这个问题简单很多了，因为如果要求连续的话，那么就不需要和上题一样遍历两遍数组，只需要比较前后的值是不是符合递增的关系。

- **第一步：确定动态规划状态** 对于这个问题，我们的状态**dp[i]也是以nums[i]这个数结尾的最长递增子序列的长度**
- **第二步：写出状态转移方程** 这个问题，我们需要分两种情况考虑，第一种情况是如果遍历到的数`nums[i]`后面一个数不是比他大或者前一个数不是比他小，也就是所谓不连续递增，那么这个数列最长连续递增序列就是他本身，也就是长度为1。 第二种情况就是如果满足有递增序列，就意味着当前状态只和前一个状态有关，状态的转移方程可以写成 `dp[i]=dp[i-1]+1`
- **第三步：考虑初始化条件** 和上面最长子序列相似，这个题目的初始化状态就是一个一维的全为1的数组。
- **第四步：考虑输出状态** 与上题相似，这个问题输出条件也是求dp数组中最大的数。
- **第五步：考虑是否可以优化** 这个题目只需要一次遍历就能求出连续的序列，所以在时间上已经没有可以优化的余地了，空间上来看的话也是一维数组，并没有优化余地。

综上所述，可以很容易得到最后的代码：

```python
class Solution(object):
    def findLengthOfLCIS(self, nums):
        if not nums:return 0  #判断边界条件
        dp=[1]*len(nums)      #初始化dp数组状态
        #注意需要得到前一个数，所以从1开始遍历，否则会超出范围
        for i in range(1,len(nums)): 
        	if nums[i]>nums[i-1]:#根据题目所求得到状态转移方程
                    dp[i]=dp[i-1]+1
                else:
                    dp[i]=1 # 不连续递增
        return max(dp)  #确定输出状态
```

**总结: 通过这个题目和例题的比较，我们需要理清子序列和子数组（连续序列）的差别，前者明显比后者要复杂一点，因为前者是不连续的序列，后者是连续的序列，从复杂度来看也很清楚能看到即使穷举子序列也比穷举子数组要复杂很多。**

承接上面的话题，我们接下来继续来看一个子序列问题，这次是另外一种涉及二维状态的题目。

_________

### [Leetcode5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)(二维dp数组)

#### 题目描述

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

```
示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

- **第一步：确定动态规划状态** 与上面两题不同的是，这个题目必须用**二维的dp数组**来记录状态，主要原因就是子串有回文的限制。用两个指针来记录子串的位置可以很好的实现子串的回文要求，又因为最后结果需要返回的是子串，必须找到具体哪个部分符合回文子串的要求。求回文子序列长度的题目[Leetcode516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/),如果有兴趣可以看一下。定义`dp[i][j]`表示子串s从i到j是否为回文子串。

  **注意：子串和子序列的区别，子串连续，子序列可以不连续。**

- **第二步：写出状态转移方程** 首先我们需要知道符合回文的条件：

  - 字符串首尾两个字符必须相等，否则不是回文。

  - 对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串 “ababa”，如果我们已经知道 “bab”是回文串，那么 “ababa” 一定是回文串，这是因为它的首尾两个字母都是 “a”。

  - 当字符串首尾两个字符相等时：如果去掉首尾字母的子串是回文，整体就是回文，这里就有了动态规划的思想，出现了子问题；相反，如果子串不是回文，那么整体肯定不是。 对于字符串`s, s[i,j]`去掉首尾字母之后子串是`s[i+1,j-1]`，如果子串只有本身或者空串，那肯定是回文子串了。所以状态转移方程不是对于`j-1-(i+1)+1<2`的情况(整理得`j-i<3`)，当`s[i]`和`s[j]`相等并且`j-i<3`时，我们可以直接得出`dp[i][j]`是True。

    综上所述，可以得到状态转移方程

    ```python
    if s[i]==s[j]:
    	if j-i<3:
    		dp[i][j]=True
    	else:
    		dp[i][j]=dp[i+1][j-1] // 状态转移方程
    ```

- **第三步：考虑初始化条件** 我们需要建立一个二维数组来表示dp，初始状态是False，又因为考虑只有一个字符的时候肯定是回文串，所以dp表格的对角线`dp[i][i]`肯定是True。

- **第四步：考虑输出状态** dp表示的是从`i`到`j`是否是回文子串，这样一来就告诉我们子串的起始位置和结束位置，但是由于我们需要找到最长的子串，所以我们优化一下可以只记录起始位置和当前长度（当然你要是喜欢记录终止位置和当前长度也是没问题的）

  ```python
  if dp[i][j]: #只要dp[i][j]成立就表示是回文子串，然后我们记录位置，返回有效答案
      cur_len=j-i+1
      if cur_len>max_len:
      	max_len=cur_len
      	start=i
  ```

- **第五步：考虑对时间，空间复杂度的优化** 对于这个问题，时间和空间都可以进一步优化，对于空间方面的优化：这里采用一种叫**中心扩散**的方法来进行，而对于时间方面的优化，则是用了**Manacher‘s Algorithm（马拉车算法）**来进行优化。具体的实现可以参考[动态规划、Manacher 算法](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/)

  这里给出比较容易理解的经典方法的代码：

  ```pyhton
   def longestPalindrome(self, s):
          length=len(s)
          if length<2:  #判断边界条件
              return s
          dp=[[False for _ in range(length)]for _ in range(length)] #定义dp状态矩阵
          #定义初始状态，这步其实可以省略
          # for i in range(length):
          #     dp[i][i]=True
          
          max_len=1
          start=0 #后续记录回文串初始位置
          for j in range(1,length):
              for i in range(j):
                  if s[i]==s[j]:
                      if j-i<3:
                      # 子串为其本身或者空
                          dp[i][j]=True
                      else:
                          dp[i][j]=dp[i+1][j-1]
                  if dp[i][j]: #记录初始位置，返回有效答案
                      cur_len=j-i+1
                      if cur_len>max_len:
                          max_len=cur_len
                          start=i
          return s[start:start+max_len]
  ```

**总结：这个是一个二维dp的经典题目，需要注意的就是定义dp数组的状态是什么，这里不用长度作为dp值而用是否是回文子串这个状态来存储也是一个比较巧妙的方法，使得题目变得容易理解。**

### 中心扩散法: 

因此中心扩散法的思路：遍历每一个索引，以这个索引为中心，利用“回文串”中心对称的特点，往两边扩散，看最多能扩散多远。

枚举“中心位置”时间复杂度为 O(N)，从“中心位置”扩散得到“回文子串”的时间复杂度为 O(N)，因此时间复杂度可以降到 O($N^{2}$)。

在这里要注意一个细节：回文串在长度为奇数和偶数的时候，“回文中心”的形式是不一样的。

    奇数回文串的“中心”是一个具体的字符，例如：回文串 "aba" 的中心是字符 "b"；
    偶数回文串的“中心”是位于中间的两个字符的“空隙”，例如：回文串串 "abba" 的中心是两个 "b" 中间的那个“空隙”。

![图 1 ：奇数回文串与偶数回文串](\pics\572db4731d6a0e32ee9c14773ed476068bebb88883335bc7415cb0b43762303a.jpg)

图 1 ：奇数回文串与偶数回文串

![图 2：枚举可能的所有回文中心](\pics\3c4ca880f2dd7463e15ddf7bbd59e2f7d11434b7dbc69b55893660012726ee88.jpg)

图 2：枚举可能的所有回文中心

我们可以设计一个方法，兼容以上两种情况：

1、如果传入重合的索引编码，进行中心扩散，此时得到的回文子串的长度是奇数；

2、如果传入相邻的索引编码，进行中心扩散，此时得到的回文子串的长度是偶数。

具体编码细节在以下的代码的注释中体现。

参考代码 5

```python
class Solution:
    def longestPalindrome(self, s):
        size = len(s)
        if size < 2:
            return s

        # 至少是 1
        max_len = 1
        res = s[0]

        for i in range(size):
            palindrome_odd, odd_len = self.__center_spread(s, size, i, i)
            palindrome_even, even_len = self.__center_spread(s, size, i, i + 1)

            # 当前找到的最长回文子串
            cur_max_sub = palindrome_odd if odd_len >= even_len else palindrome_even
            if len(cur_max_sub) > max_len:
                max_len = len(cur_max_sub)
                res = cur_max_sub

        return res

    def __center_spread(self, s, size, left, right):
        """
        left = right 的时候，此时回文中心是一个字符，回文串的长度是奇数
        right = left + 1 的时候，此时回文中心是一个空隙，回文串的长度是偶数
        """
        i = left
        j = right

        while i >= 0 and j < size and s[i] == s[j]:
            i -= 1
            j += 1
        return s[i + 1:j], j - i - 1

```

复杂度分析：

    时间复杂度：O(N2)O(N^{2})O(N2)，理由已经叙述。
    空间复杂度：O(1)O(1)O(1)，只使用到常数个临时变量，与字符串长度无关。

事实上，还有时间复杂度更优的算法，是由计算机科学家 Manacher 发明的，下面介绍这种算法。

### Manacher马拉车算法

 Manacher 算法是基于“中心扩散法”，采用和 kmp 算法类似的思想，依然是“以空间换时间”。它专门用于解决“最长回文子串”问题，时间复杂度为 O(N)。

_______

### [Leetcode516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

#### 题目描述

给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。

```
示例 1:
输入:
"bbbab"
输出:
4
```

#### 解题思路

这个问题和上面的例题也非常相似，直接套用动态规划套路也可以很快解决出来：

- **第一步：确定动态规划状态** 这里求的是**最长子串的长度**，所以我们可以直接定义一个二维的`dp[i][j]`来表示字符串第`i`个字符到第`j`个字符的长度，子问题也就是每个子回文字符串的长度。

- **第二步：写出状态转移方程** 我们先来具体分析一下整个题目状态转移的规律。对于`d[i][j]`,我们根据上题的分析依然可以看出， 当`s[i]`和`s[j]`相等时，`s[i+1:j-1]`这个字符串的长度加上2就是最长回文子序列的长度； 当`s[i]`和`s[j]`不相等时，就说明可能只有其中一个出现在s[i,j]的最长回文子序列中，我们只需要取`s[i:j-1]`和`s[i+1:j]`中较大的； 综上所述，状态转移方程也就可以写成：

  ```
  if s[i]==s[j]:
       dp[i][j]= dp[i+1][j-1]+2
  else:
  	 dp[i][j]=max(dp[i][j-1],dp[i+1][j])
  ```

  但是问题来了，具体我们应该怎么求每个状态的值呢？这里介绍一种利用状态转移表法写出状态转移方程，我们通过把`dp[i][j]`的状态转移直接画成一张二维表格，我们所要做的也就是往这张表中填充所有的状态，进而得到我们想要的结果。如下图：

![](\pics\76574ab7ff2877d63b80a2d4f8496fab3c441065552edc562f62d5809e75e97e-Snipaste_2019-05-29_15-28-02.png)

我们用字符串为"**cbbd**"作为输入来举例子，每次遍历就是求出右上角那些红色的值，通过上面的图我们会发现，按照一般的习惯都会先计算第一行的数值，但是当我们计算`dp[0,2]`的时候，我们会需要`dp[1,2]`，按照这个逻辑，我们就可以很容易发现遍历从下往上遍历会很方便计算。**一定要注意计算顺序，保证无后效性**。

- **第三步：考虑初始化条件** 很明显看出来的当只有一个字符的时候，最长回文子序列长度就是1，所以可以得到`dp[i][j]=1(i=j)` 接下来我们来看看 当`i>j`时，不符合题目要求，不存在子序列，所以直接初始化为0。 当`i<j`时，每次计算表中对应的值就会根据前一个状态的值来计算。

- **第四步：考虑输出状态**

  我们想要求最长子序列的时候，我们可以直接看出来`dp[0][-1]`是最大的值，直接返回这个值就是最后的答案。

- **第五步：考虑对时间，空间复杂度的优化** 对于这个题目，同样可以考虑空间复杂度的优化，因为我们在计算`dp[i][j]`的时候，只用到左边和下边。如果改为用一维数组存储，那么左边和下边的信息也需要存在数组里，所以我们可以考虑在每次变化前用临时变量`tmp`记录会发生变化的左下边信息。所以状态转移方程就变成了：

  ```
  if s[i] == s[j]:
      tmp, dp[j] = dp[j], tmp + 2
  else:
      dp[j] =max(dp[j],dp[j-1])
  ```

  这里给出基本版的实现代码，优化空间压缩优化解法](https://leetcode-cn.com/problems/longest-palindromic-subsequence/solution/dong-tai-gui-hua-jiang-wei-kong-jian-ya-suo-te-shu/)

  ```python
  def longestPalindromeSubseq(self, s):
          n=len(s)
          dp=[[0]*n for _ in range(n)]  #定义动态规划状态转移矩阵
          for i in range(n):  #   初始化对角线，单个字符子序列就是1
              dp[i][i]=1
          for i in range(n,-1,-1):  #从右下角开始往上遍历
              for j in range(i+1,n):
                  if s[i]==s[j]:   #当两个字符相等时，直接子字符串加2
                      dp[i][j]= dp[i+1][j-1]+2  
                  else:           #不相等时，取某边最长的字符
                      dp[i][j]=max(dp[i][j-1],dp[i+1][j])
          return dp[0][-1]   #返回右上角位置的状态就是最长
  ```

**总结：对于二维的数组的动态规划，采用了画状态转移表的方法来得到输出的状态，这种方法更加直观能看出状态转移的具体过程，同时也不容易出错。当然具体选择哪种方法则需要根据具体题目来确定，如果状态转移方程比较复杂的利用这种方法就能简化很多。**

**模板总结：**

```
            for i in range(len(nums)):
                for j in range(n):
                    if s[i]==s[j]:
                        dp[i][j]=dp[i][j]+...
                    else:
                        dp[i][j]=最值(...)
```

当然，动态规划除了解决子序列问题，也可以用来解决其他实际的问题，比如之前提到过的各种AI的经典算法，接下来我们来看一道动态规划的高频面试题，也是实际开发中很常用的。

_______

### [Leetcode72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)(高频)

给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。

#### 题目描述

```
你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符
示例 1:

输入: word1 = "horse", word2 = "ros"
输出: 3
解释: 
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

#### 解题思路

- **第一步：确定动态规划状态**

这个题目涉及到两个字符串，所以我们最先想到就是用两维数组来保存转移状态，**定义`dp[i][j]`为字符串word1长度为`i`和字符串word2长度为`j`时，word1转化成word2所执行的最少操作次数的值**。

- **第二步：写出状态转移方程**

   我们采用从末尾开始遍历`word1`和`word2`， 当`word1[i]`等于`word2[j]`时，说明两者完全一样，所以`i`和`j`指针可以任何操作都不做，用状态转移式子表示就是`dp[i][j]=dp[i-1][j-1]`，也就是前一个状态和当前状态是一样的。 当`word1[i]`和`word2[j]`不相等时，就需要对三个操作进行递归了，这里就需要仔细思考状态转移方程的写法了。 对于**插入**操作，当我们在word1中插入一个和word2一样的字符，那么word2就被匹配了，所以`dp[i][j] = dp[i][j-1]+1` 对于**删除**操作，直接表示为`dp[i][j] = dp[i-1][j]+1` 对于**替换**操作，直接表示为`dp[i][j] = dp[i-1][j-1]+1` 所以状态转移方程可以写成`min(dp[i][j-1]+1,dp[i-1][j]+1,dp[i-1][j-1]+1)`

  当 `word1[i] == word2[j]`，`dp[i][j] = dp[i-1][j-1]`；

  当` word1[i] != word2[j]`，`dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1`

  其中，`dp[i-1][j-1] `表示替换操作，`dp[i-1][j] `表示删除操作，`dp[i][j-1] `表示插入操作。

- **第三步：考虑初始化条件** 我们还是利用dp转移表法来找到状态转移的变化（读者可以自行画一张dp表，具体方法在求最长子序列中已经演示过了），这里我们用**空字符串**来额外加入到word1和word2中，这样的目的是方便记录每一步操作，例如如果其中一个是空字符串，那么另外一个字符至少的操作数都是1，就从1开始计数操作数，以后每一步都执行插入操作，也就是当`i=0`时，`dp[0][j]=j`,同理可得，如果另外一个是空字符串，则对当前字符串执行删除操作就可以了，也就是`dp[i][0]=i`，具体图示如下：

  ![Snipaste_2019-05-29_15-28-02.png](\pics\76574ab7ff2877d63b80a2d4f8496fab3c441065552edc562f62d5809e75e97e-Snipaste_2019-05-29_15-28-02.png)

  第一行，是 word1 为空变成 word2 最少步数，就是插入操作

  第一列，是 word2 为空，需要的最少步数，就是删除操作

- **第四步：考虑输出状态** 在转移表中我们可以看到，可以从左上角一直遍历到左下角的值，所以最终的编辑距离就是最后一个状态的值，对应的就是`dp[-1][-1]`。

- **第五步：考虑对时间，空间复杂度的优化** 和上题一样，这里由于`dp[i][j]`只和dp表中附近的三个状态（左边，右边和左上边）有关，所以同样可以进行压缩状态转移的空间存储，如果觉得有兴趣可以参考[@Lyncien](https://leetcode-cn.com/u/lyncien/)的解法,对于时间方面应该并没有可以优化的方法。

总结起来代码如下：

```python
       def minDistance(self, word1, word2):
        #m,n 表示两个字符串的长度
        m=len(word1) 
        n=len(word2)
        #构建二维数组来存储子问题
        dp=[[0 for _ in range(n+1)] for _ in range(m+1)]
        #考虑边界条件，第一行和第一列的条件
        for i in range(n+1):
            dp[0][i]=i  #对于第一行，每次操作都是前一次操作基础上增加一个单位的操作
        for j in range(m+1):
            dp[j][0]=j #对于第一列也一样，所以应该是1,2,3,4,5...
        for i in range(1,m+1):  #对其他情况进行填充
            for j in range(1,n+1):
                if word1[i-1]==word2[j-1]: #当最后一个字符相等的时候，就不会产生任何操作代价，所以与dp[i-1][j-1]一样
                    dp[i][j]=dp[i-1][j-1]
                else:
                    dp[i][j]=min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1 #分别对应删除，添加和替换操作
        return dp[-1][-1] #返回最终状态就是所求最小的编辑距离
```

### 普通递归解法：

```python
import functools
class Solution:
    @functools.lru_cache(None)
    def minDistance(self, word1: str, word2: str) -> int:
        if not word1 or not word2:
            return len(word1) + len(word2)
        if word1[0] == word2[0]:
            return self.minDistance(word1[1:], word2[1:])
        else:
            inserted = 1 + self.minDistance(word1, word2[1:])
            deleted = 1 + self.minDistance(word1[1:], word2)
            replace = 1 + self.minDistance(word1[1:], word2[1:])
            return min(inserted, deleted, replace)
```

________

### [Leetcode198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

#### 题目描述

```
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:

输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

#### 解题思路

- **第一步：确定动态规划状态** 直接定义题目所求的偷窃的最高金额，所以**`dp[i]`表示偷窃到第`i`号房子能得到的最高金额**。

- **第二步：写出状态转移方程** 如果我们不考虑限制条件相邻两个房子不能抢，那么问题就很简单。想得到第`i`个房间偷窃到的最高金额的时候，我们会考虑子问题前`i-1`间的最高金额`dp[i-1]`，然后再加上当前房间的金额，所以最后可以表达为`dp[i]=dp[i-1]+nums[i]`。 需要注意的是，这里限制了相邻两个房子是不能抢的，接下来我们就要考虑两种情况。 如果抢了第i个房间，那么第`i-1`肯定是不能抢的，这个时候需要再往前一间，用第`i-2`间的金额加上当前房间的金额，得到的状态转移方程是`dp[i]=dp[i-2]+nums[i]`。 如果没有抢第`i`个房间，那么肯定抢了第`i-1`间的金额，所以直接有`dp[i]=dp[i-1]`。

  最后综合一下两种情况，就可以很快得到状态转移方程：`dp[i]=max(dp[i-2]+nums[i],dp[i-1])`

- **第三步：考虑初始化条件** 初始化条件需要考虑第一个房子和第二个房子，之后的房子都可以按照规律直接求解，当我们只有一个房子的时候，自然只抢那间房子，当有两间房的时候，就抢金额较大的那间。综合起来就是`dp[0]=nums[0]，dp[1]=max(nums[0],nums[1])`。

- **第四步:考虑输出状态** 直接返回状态转移数组的最后一个值就是所求的最大偷窃金额。

- **第五步：考虑对时间，空间复杂度的优化** 时间复杂度为$O(N)$不能再优化了，空间复杂度方面如果用动态规划是不能优化，但是如果用迭代的方法只存储临时变量来记录每一步计算结果，这样可以降到$O(1)$。

这里给出动态规划版本的实现代码：

```python
     def rob(self, nums):
     
        if(not nums):   #特殊情况处理
            return 0
        if len(nums)==1:
            return nums[0]
        n=len(nums)
        dp=[0]*n    #初始化状态转移数组
        dp[0]=nums[0]  #第一个边界值处理
        dp[1]=max(nums[0],nums[1])#第二个边界值处理
        for i in range(2,n):
            dp[i]=max(dp[i-2]+nums[i],dp[i-1]) #状态转移方程
        return dp[-1]
```

时间复杂度为$O(N)$不能再优化了，空间复杂度方面如果用动态规划是不能优化，空间优化：用两个变量代替dp数组：

```python
 def rob(self, nums):
    prev = 0
    curr = 0
    for i in range(len(nums)):
        prev, curr = curr, max(prev+nums[i], curr)
    return curr
```
### [Leetcode213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

#### 题目描述

```
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:

输入: [2,3,2]
输出: 3
解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

#### 解题思路

- **第一步：确定动态规划状态**

  直接定义题目所求的偷窃的最高金额，所以**`dp[i]`表示偷窃第`i`号房子能得到的最高金额**。

- **第二步：写出状态转移方程**

  和上个题目类似，这个题目不一样的是现在所有房屋都围成一个圈，相比于上个问题又增加了一个限制，这样一来第一个房子和最后一个房子只能选择其中一个偷窃了。所有我们把这个问题拆分成两个问题：

  - 偷窃了第一个房子，此时对应的是`nums[1:]`，得到最大的金额value是`v1`。
  - 偷窃了最后一个房子，此时对应的是`nums[:n-1]`(其中n是所有房子的数量)，得到的最大金额value是`v2`。 最后的结果就是取这两种情况的最大值，即`max(v1,v2)`。

  每个子问题就和上题是一样的了，所以可以直接得到状态转移方程还是`dp[i]=max(dp[i-2]+nums[i],dp[i-1])`

- **第三步：考虑初始化条件** 初始化一个房子和两个房子的情况就是`dp[0]=nums[0]，dp[1]=max(nums[0],nums[1])`。

- **第四步：考虑输出状态** 直接返回状态转移数组的最后一个值就是所求的最大偷窃金额。

- **第五步：考虑对时间，空间复杂度的优化**

时间复杂度为$O(N)$不能再优化了，空间复杂度方面如果用动态规划是不能优化，但是如果用迭代的方法只存储临时变量来记录每一步计算结果，这样可以降到$O(1)$。

最后的代码实现：

```
def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        elif len(nums)<=2:
            return max(nums)
        def helper(nums):
            if len(nums)<=2:
                return max(nums)
            dp=[0]*len(nums)
            dp[0]=nums[0]
            dp[1]=max(nums[0],nums[1])
            for i in range(2,len(nums)):
                dp[i]=max(dp[i-1],dp[i-2]+nums[i])
            return dp[-1]
        return max(helper(nums[1:]),helper(nums[:-1]))
```

## 写在最后

动态规划是算法中比较难的类型，但是其实主要是掌握一种思维，有了这种思维，其实很难的问题都能一步一步解决好。最后再推荐一些比较优质的动态规划文章。

[掌握动态规划，助你成为优秀的算法工程师](https://www.jiqizhixin.com/articles/2019-09-29-5)

推荐MIT的动态规划练习资料，这份资料通过动态规划经典的问题让我们很清晰的了解到这个算法的魅力所在，对于新手入门动态规划是一个很不错的资料。[Dynamic Programming Practice Problems](https://people.cs.clemson.edu/~bcdean/dp_practice/)

五分钟学算法的动态规划系列: [浅谈什么是动态规划以及相关的「股票」算法题](https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247485288&idx=1&sn=fd043fc723f38bcaecc90d9945981f8a&chksm=fa0e68e9cd79e1ffd965205bb06b1731539bf2e0bbc5991664f5d1d9721b346ec08c85bb9042&scene=21#wechat_redirect) [有了四步解题法模板，再也不害怕动态规划!](https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247486904&idx=1&sn=099d5560ab25c0163349dff0c7f51490&chksm=fa0e6239cd79eb2fe6e831d7debba60aa906721d592b8766a944ef88bf91bf82568c20d71891&scene=21#wechat_redirect) [（进阶版）有了四步解题法模板，再也不害怕动态规划！](https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247486923&idx=2&sn=6c1c8aeb4db68522e67ddf8c1e933660&chksm=fa0e624acd79eb5cdb410808921609a830b9b9221e813e4eb89cf551ca48f317668d44b095d2&scene=21#wechat_redirect)

主要参考的Leetcode 优秀题解： [动态规划设计方法&&纸牌游戏讲解二分解法](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-she-ji-fang-fa-zhi-pai-you-xi-jia/) [动态规划、Manacher 算法](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/) [编辑距离面试题详解](https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-mian-shi-ti-xiang-jie-by-labuladong/) [打家劫舍 II（动态规划，结构化思路，清晰题解）](https://leetcode-cn.com/problems/house-robber-ii/solution/213-da-jia-jie-she-iidong-tai-gui-hua-jie-gou-hua-/)